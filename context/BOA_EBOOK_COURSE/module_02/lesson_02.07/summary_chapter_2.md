---
title: Summary Chapter 2
description: Wrap up of frontend architectures module.
---

# Summary

This first chapter touched upon many intriguing points, and a wealth of information was shared. Attempting to summarize the shared information in these paragraphs is the next step.

The discussion began with the history of the frontend world. Evolution has been rapid in recent years; fortunately, things have evolved for the better. In fact, configuring projects has become simpler than in previous years, thanks to the advent of CLIs, command-line tools that allow for quick scaffolding of projects. Now, any modern framework with a basic application can start with one or two commands. A nostalgic recall of when each project had its personalized configuration, each process, and each task was the result of study and attempts to find the ideal solution for the infrastructure.

Moreover, transitioning from one bundle tool to another was complex because the migration guides were there, but today, many tools allow automatic updating. Significant strides have been made to make the contents easily usable on the documentation side. Consider, for example, the Qwik documentation. The search bar allows for searching within all the documentation automatically because there are tools that index the contents behind the scenes and enable this type of user experience.

But that's not all. Through AI, a question can be asked, and an answer can be waited for a few seconds, which is most of the time accurate and immediately provides the necessary solution to solve the requested problems. These AI tools are phenomenal because they learn from themselves. Every time negative feedback is provided concerning a result, they manage to learn and improve day after day.

The various frontend architectures and the types of rendering were analyzed continuing in the chapter. Each choice has its pros and cons because, as with all choices, the perfect solution does not exist. It is always a compromise between pros and cons. All the approaches examined together leave a lot of responsibility to the developer, who will have to decide which parts of the application to lazy load in the case of SPA.

The Hydration process was analyzed, and it was observed that different approaches were born to limit this poorly performing process over time. If it had been optimal, other ways to perform it better would not have arisen. It was seen that Island Architecture tries to find a solution while leaving the decision to the developers on how to divide the application to limit the Hydration problem.

The same thing can be considered regarding the React Server Components. The developer has the burden of deciding upfront which are the server and client components. These are important decisions that changing during construction could be costly regarding refactoring.

At the end of the chapter, it was mentioned that things are different with Qwik. The framework optimally solves these problems. Furthermore, a preview of the next chapter can be given, and it can be said that the Developer Experience also takes the weight off the developer's shoulders on making the reasoning seen previously. Therefore, it removes the headaches of having to optimize the application because it is done by default for them by the framework.

As a premise, it can be said that it doesn't seem bad at all. So, there is no point in waiting. Let's continue straight to the next chapter!
