---
title: Page views tracking
description: Let's try the Supabase database function. This is an easy way to allows us to do several things and also add some logic to our procedure.
code: https://gitlab.com/fullstackio/books/newline-course-apps/giorgio-boa-qwik-in-action-app/-/tree/main/module_10
---

# Page views tracking

Excellent, well done. Now another nice feature that we can add to our application is to be able to track how many times one of our pages is viewed and to do this we will take advantage of some advanced features of Supabase.
First of all, however, let's create the table that will host our data.
Let's create the file to write our SQL.

```shell
pnpm supabase migration new page_views
```

Let's write the SQL that will generate our table to contain the information we need.

```SQL
create table public.page_views (
  id bigint generated by default as identity,
  page text not null,
  views bigint null default '1'::bigint,
  last_update timestamp without time zone not null default now(),
  constraint page_views_pkey primary key (id),
  constraint page_views_page_key unique (page)
) tablespace pg_default;

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.increment_views(page_slug text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$BEGIN
    IF EXISTS (SELECT FROM page_views WHERE page=page_slug) THEN
        UPDATE page_views
        SET views = views + 1,
            last_update = now()
        WHERE page = page_slug;
    ELSE
        INSERT into page_views(page) VALUES (page_slug);
    END IF;
END;$function$
;
```

Additionally, we can see that we have defined a Supabase database function that allows us to do several things and also add some logic to our procedure. We can see that this function accepts a `page_slug` parameter and then a conditional check is performed. If a record already exists for this specific page then we are going to increase the number of views for the specific page and we are also going to update the last update of the page. However, if the searched record is not present then one is created, the default value of `views` will be 1 and the current date will be inserted for the `last_update` field. Now we have everything configured to be able to track the views of our pages.

Now we can go and apply our changes to the database with the following command:

```shell
pnpm supabase db reset
```

Let's now move on to our Qwik application, and insert the logic to be able to call our function at the right time.

FILE: `src/routes/detail/[slug]/index.tsx`

```tsx
import { supabaseClient } from "~/utils/supabase";

export const onGet: RequestHandler = async ({ params, next }) => {
  await supabaseClient.rpc('increment_views', { page_slug: params.slug });
  await next();
}

export const useProductDetail = routeLoader$(async ({ params, resolveValue }) => {
  [...]
});

export default component$(() => {
  [...]

  return (
    <div>
      [...]
    </div>
  );
});
```

We have added an `onGet` middleware to the top of our `src/routes/detail/[slug]/index.tsx` page, which shows the item detail. This allows us to execute code when our page is called in GET and in fact when we go to visit a specific URL with our browser we are executing an HTTP GET operation. In this method, we are performing server-side operations, and specifically, we are going to call the database function that we defined in our database. We can see that we are also passing the parameter that is needed by the function to execute the logic correctly.
We could have used the methods seen previously to write and read our data from the Supabase database, but I thought it was a great way to show you how to use database functions. If we think about it carefully, we are moving the logic to the database side because the computation and the logic are not inside our application, but are moved to the database. It is an interesting way to be able to remove logic from our frontend application although it is always better to make a very precise choice on how to manage these operations, either all of them in the frontend part or moving all the logic to the database.
With this implementation, as soon as we load our page, our database is immediately updated. But usually, this is not what we want because we would be more interested in understanding whether a page has been viewed or not. Let's imagine we want to say: "My product has been seen and therefore I increase visits only if the end user has seen the image". With Qwik, performing this type of operation is very simple because we can create a component and then connect the backend logic. For example, when the user hovers over our product image or when a specific component is displayed.
Thanks to the `useOnDocument` API we can listen to the `mousemove` event and check when the mouse position is above our component. We could also have used the `useVisibleTask$` API to execute logic when our component is visible, but as explained in the previous chapters it is necessary to limit the eager execution of JavaScript as much as possible to keep our application fast and performing.
