---
title: Overview of application testing
description: Let's explore together the benefit of testing. In this lesson you will explore the various types of tests, Unit Test, E2E, Visual regression tests and more.
---

# Overview of application testing

How many times have we written a new piece of code and, due to a side effect, ended up breaking another feature we weren't expecting? These types of problems are commonly called regression errors. It often happens that if our code is strongly coupled and shares business logic, changing the logic connected to it also affects other parts of the application. How can we be sure that our changes or evolutions do not create problems in production?
A good test suite is able to prevent this kind of problems. Another benefit that should not be underestimated regarding testing is certainly that of being able to detect errors in advance directly during the development phase. So even before integrating the code into your final bundle, you may realize that something doesn't work as it should. This guarantees you save time and greatly reduces errors that can occur in production. In fact, if a problem arises a few weeks after our code has reached production, it will be more complex to identify and solve the problem.
Having a good test suite also allows us to facilitate refactoring activities, i.e., the process of fixing existing code to make it more manageable, and scalable but not only. Refactoring is an essential part of software development that allows us to evolve and improve the code of our application and reduce technical debt. Tests act as checkers that allow us to check whether the refactoring of our code has introduced errors or created regressions. Having clean code in the long term allows you to be more productive and therefore save money and time. The most important advantage, however, is the knowledge that we are following the implementation of high-quality code. Whether we are working on a small application, or even more so on a large one, we are aware that what we have tested works correctly, and therefore we have not changed the behavior which until now has allowed us to have an application that works correctly. To write a good test suite, however, it is important to dedicate effort and resources to be able to derive the benefits we have mentioned. Precisely because it takes time, many companies that I have had the opportunity to meet in my career have never fully believed in testing, a practice that was born many years ago and has evolved over time. With the advent of software, we have had an explosion of innovation and nowadays there are many programs to perform tests, both manual and automatic. Automatic ones were created precisely to limit the time investment that was mentioned before, and to speed up all those repetitive tasks that do not require a person to carry them out.
However, various types of tests touch on different areas of our application, because they are focused on different scopes. Let's look at this distinction together.

## Unit tests

Unit tests are very important because they focus on the logic part of our application. They allow us to write robust and reliable code. This type of test focuses on a single functionality, and therefore we can only focus on a few lines of code. The functions that are tested are pure functions; i.e., they do not have side effects within them. The most classic example is testing the sum function, given a certain input (two numbers) I provide an output. Let's imagine inserting a logic within the function according to which, on Monday, the sum works differently compared to the other days of the week. In this case, we are adding unpredictability within our function and making our code very difficult to test. Pure functions give us a big advantage in terms of stability and predictability of our code because we can always have the situation under control.

We know with certainty that our business algorithms do not change. If we have discount policies that are based on the total amount of the goods our user is purchasing, we can verify the logic with a specific test and verify that, following the evolutions of our software, our algorithm is not affected.
This algorithm will be covered with various tests that verify the logic with different amounts and will be put under stress with edge cases that perhaps will bring out some cases not considered. A striking case could be that of having an amount which, net of promotions, entitles you to 20% of the total. Does this rule also apply if my user has already applied a 50% promotional discount for the spring sales? Which of the two discounts should I keep? If we think about it carefully, when we go to design an algorithm, these are questions that we already ask ourselves, but with the help of tests it is easier for us to define them. We have the possibility of isolating the scope leaving out the rest of the application to concentrate on the single piece of code. This approach therefore also helps us to better design our applications by focusing on real cases and avoiding predicting edge cases upfront. I know you are thinking that these are logical problems most of the time, and usually they are in the back-end. So, I'll give you another example, which is purely frontend. Let's take the product detail page seen before in our application. A unit test that can be developed is to verify that if I am inside the detail of a product, the name of the product I requested is present in the viewport. This guarantees us that our page is correct because by checking that all the information is in the right place, we can make the code that renders the detail page robust. The low cost in terms of effort and their simplicity make these types of tests an essential aid to our application development and the future evolutions we will make. This type of test also implicitly creates a sort of documentation of how the application should work and makes clear a whole series of cases that the application takes into consideration. By looking at a correctly written test suite we will be able to quickly understand the logic behind a certain piece of code, this aspect is very powerful. Another factor to consider is the fact of structuring our code with functions that are as atomic as possible to make any type of operation trivial. There should be no surprises in the code. This is a good practice not only for testing, but programming in general. If you have never read [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) by Robert C. Martin, I recommend you do so because you will find many interesting ideas on best practices for writing quality code.

## Visual regression tests

As we can understand from the name, Visual regression tests are tests where a particular aspect of our frontend application is examined.
This type of testing is based on user interface comparison and specifically compares two versions to ensure that there are no unwanted changes.
As mentioned, two versions of our interface are compared, the current version with our changes and a previous version that has been appropriately saved. Thanks to specific tools it is possible to take a "photograph" of the current version which will then be compared with the one to be published. This type of testing helps ensure graphical consistency across different devices, operating systems, and browsers. When we go to make changes to our application it is very expensive in terms of time to test on all these combinations, and it is not even possible to have all the supported devices available to check that everything is as desired. Furthermore, it is very complex to identify the graphic differences between two interfaces. Have you ever played "Spot the Difference"? Well, it's a very similar experience to the one you can have when playing this game. However, when we have to perform a release it is anything but a game because the pressure to solve the problem is high. Automated solutions, on the other hand, make this verification cycle smooth which can save you from bugs in production. These tools are very precise because they analytically check pixel by pixel to find defects. Making a catastrophic hypothesis we can think of the fact that some buttons have become too small to be tapped from mobile, and therefore, our mobile users will not be able to use our application.

## Integration tests

Integration tests are particular types of tests that focus on the iteration between two or more parts of the application, and are slightly more expensive than unit tests because more parts of the application need to be coordinated together. If we were to explain the integration tests with a simple example we could take the case study of sending emails following registration. The user registers, and we send a greeting email. This integration test, though, is very backend-oriented, but it's easy to think of this flow. As done previously, let's try to see these tests from the frontend side, things are slightly different. We can imagine having a login form for our application, a good integration test could be to test if we can log in to the application. So thanks to the tools that we will later exam, we can go and render our login page, we can fill in the fields automatically, and then go and log in within the application. All this involves various integration steps, validation of the forms to verify that we have entered current data, and when we press the submit button we also verify that the call is executed. Once we receive the response we will also proceed to the application homepage. Often, the login calls, or more generally, are simulated so as not to include backend management in these tests. When we develop, we don't have both up-and-running environments on our local machine, and logging into staging or production environments is not the wisest thing. After all, we want to run tests and not create confusion. As long as we talk about login it can be ok, but when we have to try to close an order or create a user it is not something to do.
Writing this type of test requires time, but the advantages are many. First of all, we are going to add value and security to our application because we are going to guarantee that the specific functionality continues to work during releases. Another aspect that should not be underestimated is that in this case too we are implicitly documenting how the flows of our application must work, and how the systems must interact. These tests are very useful and help us lay the foundation for end-to-end testing.

## End-to-end tests

These types of tests were born with the idea of being able to control the flow of our application from start to the end. These types of controls are much more expensive to maintain in the long run because our interface continually changes with the implementation of new features. An example of an end-to-end flow could be to start by logging into the application, continue with the test by entering the order list, and finish with the download and verification of the order selected by us. Already from this description, we can see that it is truly an all-round test because we are testing the entire flow. If we think about it, we are putting together many integration tests to test a more complex one. Writing these types of tests is very burdensome and some tools have implemented a user action recording functionality for some time now. Let me explain better. In practice, these tools allow us to record all the actions we do in our application and then convert them into code that can be used to reproduce the sequence whenever we want. This approach allows you to significantly reduce the writing times of these tests and partially solve one of the weak points of end-to-end tests. The other problem present is that of maintaining the tests in the long term because it is easy for the position of our components to change, the same can be said for the styles and much more. Various conditions certify whether a test is correct or not, but the most used are based on the presence of DOM elements or CSS classes, this makes end-to-end tests very fragile indeed. On the other hand, they give us a complete picture of the flow that the user can complete from start to finish and manage to find problems that are not evident with other types of tests. If we don't already have a visual regression test suite, an end-to-end flow for certain browsers might have compatibility problems. Perhaps features that are not cross-browser compatible have been used, and therefore, automatically testing the flows is a really good thing to give a positive user experience regardless of the browser they use. We can simulate access to the platform by different users, with different roles and with different views. In short, if you have time to expand these tests, there is a lot to do. In my experience, what I have seen done most is to concentrate most of the effort on testing the core flow and then possibly covering the less priority flows.
It's an excellent way not to give up these very important tests, but also calibrate the effort they unfortunately require.

## Accessibility tests

Accessibility in modern applications has become fundamental and is also required at a legislative level, so we cannot hide and pretend it doesn't exist. The basic principle is to be able to allow everyone to use the application regardless of their ability or disability. There are various ways to check if our application is accessible, the most common is to test our application using screen readers or other assistive technologies, but it is possible to run tests with users with different disabilities and verify compliance with accessibility standards.
Some automatic tools analyze and interact with our application to verify that it complies with [W3C standards](https://www.w3.org/WAI/standards-guidelines/) to guarantee equal opportunities for everyone.
