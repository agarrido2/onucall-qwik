---
title: Summary Chapter 9
description: Wrap up of Supabase module.
code: https://gitlab.com/fullstackio/books/newline-course-apps/giorgio-boa-qwik-in-action-app/-/tree/main/module_09
---

# Summary

This chapter was full of content, we immediately saw how to use the Supabase CLI, which dependencies are necessary, and what the commands are to recreate the remote database even locally. The advantages are undeniable because it allows us to work in peace, freeing us from the remote database. Together we modified the database created in the previous chapter and created migration files to modify the database automatically. We also created a seed to initialize the database with useful data for local development. Thanks to Docker and the Supabase CLI this process is very smooth. We have seen how we can update our remote database via the command line, but we also discovered that the most correct process is to tie the implemented functionality and the database modification together. All this is possible thanks to GitHub actions, by doing so the database will only change when necessary, when our code requests new data from the database. By doing so, many errors are avoided and there is no possibility of creating inconsistent situations. In our Qwik application via `routeLoader$`, we read our products from the newly created table. We rendered the various products on the homepage, and we inserted the image, and the data relating to the product (name, description, price). Finally, again using a `routeLoader$`, we checked whether there was a logged-in user or not. If the user is logged in he will see the "Add to cart" button otherwise he will see a button which behind the scenes, thanks to the navigate API, will direct the user to the Sign in page. We have created a search bar to allow our users to search within our catalog. Thanks to the interesting Orama tolerance functionality we can also correct any typing errors made by the user and equally recommend a product to purchase. With the `server$` API, we were able to execute our server-side code in a completely safe and fluid manner without having to worry. At the end of the chapter, we also implemented a detail page for our products, together we analyzed how to manage dynamic routes and we modified our database by adding the slug field to the products table. Finally, we have analyzed in detail the Cache-control headers which allow us to save a lot of money in the management of our infrastructure, because they take the load off the server with the intelligent use of the cache, both at the browser and CDN level.
In the next chapter, we will add new features to our application such as adding our products to the cart and managing the checkout process with Stripe.
